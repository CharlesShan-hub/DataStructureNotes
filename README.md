# DataStructureNotes
数据结构笔记  
This repository is created for revision and conclusion for data structure learning.  
这个仓库用于分享我在学习数据结构的笔记与总结的代码, 欢迎大家提出各种建议.
charles.shht@gmail.com
## 线性表

### 线性表文件夹中包含以下内容 

|                   |顺序表|  |链式储存|||||
|:-|:-:|-:|-:|-:|-:|-:|-:|
|                    |静态 |动态|单链表(头节点)|单链表(无头节点)|双链表|循环链表|静态链表|
|Define              |√   |√   |√           |√            |√    |√     |√      |
|InitList(&L)        |√   |√   |√           |√            |√    |√     |-      |
|Empty(L)            |-   |-   |√           |√            |-    |√     |-      |
|IsTail(&L,&Node)    |-   |-   |-           |-            |-    |√     |-      |
|Length(L)           |-   |-   |O(n)        |O(n)         |-    |-     |-      |
|IncreaseSize(&L,len)|-   |√   |-           |-            |-    |-     |-      |
|LocateElem(L,e)     |O(1)|O(1)|O(n)        |O(n)         |-    |-     |-      |
|GetItem(L,i)        |O(n)|O(n)|O(n)        |O(n)         |-    |-     |-      |
|ListInsert(&L,i,e)  |O(n)|O(n)|O(n)        |O(n)         |-    |-     |-      |
|InsertPoier(&L,e)   |-   |-   |O(1)        |O(1)         |-    |-     |-      |
|InsertNext(&L,e)    |-   |-   |O(1)        |O(1)         |√    |-     |-      |
|ListDelete(&L,i,&e) |O(n)|O(n)|O(n)        |-            |√    |-     |-      |
|DeleteNode(&N)      |-   |-   |O(1)        |O(1)         |-    |-     |-      |
|DestoryList(&L)     |-   |-   |O(n)        |O(n)         |-    |-     |-      |
|尾插法               |-   |-   |√           |√            |-    |-     |-      |
|头插法               |-   |-   |√           |√            |-    |-     |-      |

__√__: 可以实现.   
__O(..)__: 可以实现, 并写出了时间复度.  
__-__: 没有对应函数, 或尚未写出该函数.  

### 一些小点
1. 线性表包含顺序存储与链式存储. 顺序存储(顺序表)中又包含静态分配与动态存储. 
2. 单链表不带头节点的按位插入操作, 会比较麻烦, 一般都写带头节点的形式.
3. 单链表的前插法可以从后插法改编而成. 先后插再为原节点重新赋值, 达到与前插等效的目的.
4. 在初始化链表节点的时候, 养成Node.next=NULL的好习惯.
5. 链表头插法的策略常用于“链表逆置”.
6. 循环单链表不一样的地方就是初始化的时候next指向自己. “L->Next==L”,(“L->Primer==L”).
7. 思考各种链表如何判空, 如何判断在表头或表尾, 如何在表头表中表尾增删元素有无特殊处理.
8. 静态链表由[数组+游标]组成, 游标中存放下一个元素的下标, 最后一个节点下标是-1.

### 顺序表与链表对比
#### 逻辑结构
都是线性表
#### 储存结构
顺序表 - 随机存取, 存储密度高, 但是分配空间与扩容不方便.
链表 - 分配空间与扩容方便, 存储密度低, 查找麻烦(不能随机存取).
#### 数据运算
__创建__ -  顺序表分一整片, 过小不好扩容, 过大浪费空间; 链表分配扩展空间容易.  
__销毁__ - 链表依次free各个节点; 顺序表修改length=0(静态分配的回收空间由系统进行, 动态分配的回收空间需要手动free).  
__增删__  - 顺序表需要前后移动O(n), 链表也是O(n),时间开销来自查找元素n. 不过寻找带来的时间开销比移动元素快得多, 所以还是
 链表效率更高.  
__改查__  - 顺序表按位查找O(1),安置查找如果顺序表元素无序O(n),有序可以优化算法; 
  链表无论有序无序, 都是O(n).
#### 总结
顺序表适合查, 链表适合动态分配与增删.  

## 栈与队列
### 栈与队列文件夹中包含下面内容 

|          |顺序栈(数组)|共享栈(数组)|链栈|
|:-|:-:|:-:|:-:|
|Define           |√         |√   |√  |
|InitStack(&S)    |√         |√   |√  |
|DestroyStack(&S) |-         |-   |-  |
|Push(&S,x)       |√         |-   |√  |
|Pop(&S)          |√         |-   |√  |
|GetTop(S,&x)     |√         |-   |√  |
|Empty(S)         |√         |-   |√  |

| 队列的基本操作           |顺序||
|:-|:-:|:-:|
|Define           |√         |          |
|InitQueue(&Q)    |√         |          |
|DestroyQueue(&Q) |-         |          |
|EnQueue(&Q,x)    |√         |          |
|DeQueue(&Q,&x)   |√         |          |
|GetHead(Q,&x)    |√         |          |
|Empty(Q)  [爱考]  |√         |          |

__√__: 可以实现.   
__O(..)__: 可以实现, 并写出了时间复度.  
__-__: 没有对应函数, 或尚未写出该函数.  

### 笔记总结
#### 栈的定义
1. 只允许在一端进行插入或删除的线性表; 栈顶, 栈底, 空栈.  
2. 基本操作: 创,增,删,查,判空,(判满).
3. 先进后出(LIFO)  -Last in First out
4. n个元素进栈, 出栈的种类$\frac{C_{2n}^{n}}{n+1}$
5. 共享栈, 两头两个栈.

#### 队列的定义
1. 只允许在一端插入, 另一端删除.
2. 先进先出(FIFO) - First in First out
3. 基本操作: 创,增,删,查.
4. Q.front指向队头元素, 队尾指针指向下一个要插入的元素.
5. 注意判满操作: ```(Q.rear+1)%MaxSize  == Q.front;```
6. 注意判空操作: ```Q.front == Q.rear;```
7. __队头队尾指针意义__: 1. 队尾指针可能指向下一个要插入的元素(上述叙述), 2. 也可以能指向最后一个内容, 考试时要注意.
8. 三种 __实现方案__: a. 牺牲一个存储空间(5和4). b. 增加size元素记录队列长度. c. 增加tag = 0/1, 标记最近一次操作是出队还是入队.
9. __重要操作__: 如何初始化, 入队, 出队, 判空, 判满, 计算队列长度.
10. 分别思考: (8和9的组合) - 1a,1b,1c,2a,2b,2c.
